
x10_sender_test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000066  00800200  000004b4  00000548  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000004b4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000068  00800266  00800266  000005ae  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000005ae  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000005e0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000088  00000000  00000000  00000620  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000123e  00000000  00000000  000006a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ebf  00000000  00000000  000018e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000059e  00000000  00000000  000027a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001ec  00000000  00000000  00002d44  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000720  00000000  00000000  00002f30  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000004cb  00000000  00000000  00003650  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000068  00000000  00000000  00003b1b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	72 c0       	rjmp	.+228    	; 0xe6 <__ctors_end>
   2:	00 00       	nop
   4:	03 c1       	rjmp	.+518    	; 0x20c <__vector_1>
   6:	00 00       	nop
   8:	9c c0       	rjmp	.+312    	; 0x142 <__bad_interrupt>
   a:	00 00       	nop
   c:	9a c0       	rjmp	.+308    	; 0x142 <__bad_interrupt>
   e:	00 00       	nop
  10:	98 c0       	rjmp	.+304    	; 0x142 <__bad_interrupt>
  12:	00 00       	nop
  14:	96 c0       	rjmp	.+300    	; 0x142 <__bad_interrupt>
  16:	00 00       	nop
  18:	94 c0       	rjmp	.+296    	; 0x142 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	92 c0       	rjmp	.+292    	; 0x142 <__bad_interrupt>
  1e:	00 00       	nop
  20:	90 c0       	rjmp	.+288    	; 0x142 <__bad_interrupt>
  22:	00 00       	nop
  24:	8e c0       	rjmp	.+284    	; 0x142 <__bad_interrupt>
  26:	00 00       	nop
  28:	8c c0       	rjmp	.+280    	; 0x142 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	8a c0       	rjmp	.+276    	; 0x142 <__bad_interrupt>
  2e:	00 00       	nop
  30:	88 c0       	rjmp	.+272    	; 0x142 <__bad_interrupt>
  32:	00 00       	nop
  34:	86 c0       	rjmp	.+268    	; 0x142 <__bad_interrupt>
  36:	00 00       	nop
  38:	84 c0       	rjmp	.+264    	; 0x142 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	82 c0       	rjmp	.+260    	; 0x142 <__bad_interrupt>
  3e:	00 00       	nop
  40:	80 c0       	rjmp	.+256    	; 0x142 <__bad_interrupt>
  42:	00 00       	nop
  44:	7e c0       	rjmp	.+252    	; 0x142 <__bad_interrupt>
  46:	00 00       	nop
  48:	7c c0       	rjmp	.+248    	; 0x142 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	7a c0       	rjmp	.+244    	; 0x142 <__bad_interrupt>
  4e:	00 00       	nop
  50:	79 c0       	rjmp	.+242    	; 0x144 <__vector_20>
  52:	00 00       	nop
  54:	76 c0       	rjmp	.+236    	; 0x142 <__bad_interrupt>
  56:	00 00       	nop
  58:	74 c0       	rjmp	.+232    	; 0x142 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	72 c0       	rjmp	.+228    	; 0x142 <__bad_interrupt>
  5e:	00 00       	nop
  60:	70 c0       	rjmp	.+224    	; 0x142 <__bad_interrupt>
  62:	00 00       	nop
  64:	6e c0       	rjmp	.+220    	; 0x142 <__bad_interrupt>
  66:	00 00       	nop
  68:	6c c0       	rjmp	.+216    	; 0x142 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	6a c0       	rjmp	.+212    	; 0x142 <__bad_interrupt>
  6e:	00 00       	nop
  70:	68 c0       	rjmp	.+208    	; 0x142 <__bad_interrupt>
  72:	00 00       	nop
  74:	66 c0       	rjmp	.+204    	; 0x142 <__bad_interrupt>
  76:	00 00       	nop
  78:	64 c0       	rjmp	.+200    	; 0x142 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	62 c0       	rjmp	.+196    	; 0x142 <__bad_interrupt>
  7e:	00 00       	nop
  80:	60 c0       	rjmp	.+192    	; 0x142 <__bad_interrupt>
  82:	00 00       	nop
  84:	5e c0       	rjmp	.+188    	; 0x142 <__bad_interrupt>
  86:	00 00       	nop
  88:	5c c0       	rjmp	.+184    	; 0x142 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	69 c0       	rjmp	.+210    	; 0x160 <__vector_35>
  8e:	00 00       	nop
  90:	58 c0       	rjmp	.+176    	; 0x142 <__bad_interrupt>
  92:	00 00       	nop
  94:	56 c0       	rjmp	.+172    	; 0x142 <__bad_interrupt>
  96:	00 00       	nop
  98:	54 c0       	rjmp	.+168    	; 0x142 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	52 c0       	rjmp	.+164    	; 0x142 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	50 c0       	rjmp	.+160    	; 0x142 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	4e c0       	rjmp	.+156    	; 0x142 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	4c c0       	rjmp	.+152    	; 0x142 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	4a c0       	rjmp	.+148    	; 0x142 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	48 c0       	rjmp	.+144    	; 0x142 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	80 c0       	rjmp	.+256    	; 0x1b6 <__vector_45>
  b6:	00 00       	nop
  b8:	44 c0       	rjmp	.+136    	; 0x142 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	42 c0       	rjmp	.+132    	; 0x142 <__bad_interrupt>
  be:	00 00       	nop
  c0:	40 c0       	rjmp	.+128    	; 0x142 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	3e c0       	rjmp	.+124    	; 0x142 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	3c c0       	rjmp	.+120    	; 0x142 <__bad_interrupt>
  ca:	00 00       	nop
  cc:	3a c0       	rjmp	.+116    	; 0x142 <__bad_interrupt>
  ce:	00 00       	nop
  d0:	38 c0       	rjmp	.+112    	; 0x142 <__bad_interrupt>
  d2:	00 00       	nop
  d4:	36 c0       	rjmp	.+108    	; 0x142 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	34 c0       	rjmp	.+104    	; 0x142 <__bad_interrupt>
  da:	00 00       	nop
  dc:	32 c0       	rjmp	.+100    	; 0x142 <__bad_interrupt>
  de:	00 00       	nop
  e0:	30 c0       	rjmp	.+96     	; 0x142 <__bad_interrupt>
	...

000000e4 <__ctors_start>:
  e4:	6d 01       	movw	r12, r26

000000e6 <__ctors_end>:
  e6:	11 24       	eor	r1, r1
  e8:	1f be       	out	0x3f, r1	; 63
  ea:	cf ef       	ldi	r28, 0xFF	; 255
  ec:	d1 e2       	ldi	r29, 0x21	; 33
  ee:	de bf       	out	0x3e, r29	; 62
  f0:	cd bf       	out	0x3d, r28	; 61
  f2:	00 e0       	ldi	r16, 0x00	; 0
  f4:	0c bf       	out	0x3c, r16	; 60

000000f6 <__do_copy_data>:
  f6:	12 e0       	ldi	r17, 0x02	; 2
  f8:	a0 e0       	ldi	r26, 0x00	; 0
  fa:	b2 e0       	ldi	r27, 0x02	; 2
  fc:	e4 eb       	ldi	r30, 0xB4	; 180
  fe:	f4 e0       	ldi	r31, 0x04	; 4
 100:	00 e0       	ldi	r16, 0x00	; 0
 102:	0b bf       	out	0x3b, r16	; 59
 104:	02 c0       	rjmp	.+4      	; 0x10a <__do_copy_data+0x14>
 106:	07 90       	elpm	r0, Z+
 108:	0d 92       	st	X+, r0
 10a:	a6 36       	cpi	r26, 0x66	; 102
 10c:	b1 07       	cpc	r27, r17
 10e:	d9 f7       	brne	.-10     	; 0x106 <__do_copy_data+0x10>

00000110 <__do_clear_bss>:
 110:	22 e0       	ldi	r18, 0x02	; 2
 112:	a6 e6       	ldi	r26, 0x66	; 102
 114:	b2 e0       	ldi	r27, 0x02	; 2
 116:	01 c0       	rjmp	.+2      	; 0x11a <.do_clear_bss_start>

00000118 <.do_clear_bss_loop>:
 118:	1d 92       	st	X+, r1

0000011a <.do_clear_bss_start>:
 11a:	ae 3c       	cpi	r26, 0xCE	; 206
 11c:	b2 07       	cpc	r27, r18
 11e:	e1 f7       	brne	.-8      	; 0x118 <.do_clear_bss_loop>

00000120 <__do_global_ctors>:
 120:	10 e0       	ldi	r17, 0x00	; 0
 122:	c3 e7       	ldi	r28, 0x73	; 115
 124:	d0 e0       	ldi	r29, 0x00	; 0
 126:	00 e0       	ldi	r16, 0x00	; 0
 128:	05 c0       	rjmp	.+10     	; 0x134 <__do_global_ctors+0x14>
 12a:	21 97       	sbiw	r28, 0x01	; 1
 12c:	01 09       	sbc	r16, r1
 12e:	80 2f       	mov	r24, r16
 130:	fe 01       	movw	r30, r28
 132:	b6 d1       	rcall	.+876    	; 0x4a0 <__tablejump2__>
 134:	c2 37       	cpi	r28, 0x72	; 114
 136:	d1 07       	cpc	r29, r17
 138:	80 e0       	ldi	r24, 0x00	; 0
 13a:	08 07       	cpc	r16, r24
 13c:	b1 f7       	brne	.-20     	; 0x12a <__do_global_ctors+0xa>
 13e:	a1 d0       	rcall	.+322    	; 0x282 <main>
 140:	b7 c1       	rjmp	.+878    	; 0x4b0 <_exit>

00000142 <__bad_interrupt>:
 142:	5e cf       	rjmp	.-324    	; 0x0 <__vectors>

00000144 <__vector_20>:

Sender x10Sender(0b0110);


ISR(TIMER1_OVF_vect)
{
 144:	1f 92       	push	r1
 146:	0f 92       	push	r0
 148:	0f b6       	in	r0, 0x3f	; 63
 14a:	0f 92       	push	r0
 14c:	11 24       	eor	r1, r1
	TCCR0B = 0b00000000;
 14e:	15 bc       	out	0x25, r1	; 37
	TCCR1B = 0b00000000;
 150:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	DDRB &= 0b01111111;
 154:	27 98       	cbi	0x04, 7	; 4
}
 156:	0f 90       	pop	r0
 158:	0f be       	out	0x3f, r0	; 63
 15a:	0f 90       	pop	r0
 15c:	1f 90       	pop	r1
 15e:	18 95       	reti

00000160 <__vector_35>:

ISR(TIMER3_OVF_vect)
{
 160:	1f 92       	push	r1
 162:	0f 92       	push	r0
 164:	0f b6       	in	r0, 0x3f	; 63
 166:	0f 92       	push	r0
 168:	11 24       	eor	r1, r1
 16a:	0b b6       	in	r0, 0x3b	; 59
 16c:	0f 92       	push	r0
 16e:	2f 93       	push	r18
 170:	3f 93       	push	r19
 172:	4f 93       	push	r20
 174:	5f 93       	push	r21
 176:	6f 93       	push	r22
 178:	7f 93       	push	r23
 17a:	8f 93       	push	r24
 17c:	9f 93       	push	r25
 17e:	af 93       	push	r26
 180:	bf 93       	push	r27
 182:	ef 93       	push	r30
 184:	ff 93       	push	r31
	TCCR3B = 0b00000000;
 186:	10 92 91 00 	sts	0x0091, r1	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
	x10Sender.zeroCross();
 18a:	86 e6       	ldi	r24, 0x66	; 102
 18c:	92 e0       	ldi	r25, 0x02	; 2
 18e:	0b d1       	rcall	.+534    	; 0x3a6 <_ZN6Sender9zeroCrossEv>
}
 190:	ff 91       	pop	r31
 192:	ef 91       	pop	r30
 194:	bf 91       	pop	r27
 196:	af 91       	pop	r26
 198:	9f 91       	pop	r25
 19a:	8f 91       	pop	r24
 19c:	7f 91       	pop	r23
 19e:	6f 91       	pop	r22
 1a0:	5f 91       	pop	r21
 1a2:	4f 91       	pop	r20
 1a4:	3f 91       	pop	r19
 1a6:	2f 91       	pop	r18
 1a8:	0f 90       	pop	r0
 1aa:	0b be       	out	0x3b, r0	; 59
 1ac:	0f 90       	pop	r0
 1ae:	0f be       	out	0x3f, r0	; 63
 1b0:	0f 90       	pop	r0
 1b2:	1f 90       	pop	r1
 1b4:	18 95       	reti

000001b6 <__vector_45>:

ISR(TIMER4_OVF_vect)
{
 1b6:	1f 92       	push	r1
 1b8:	0f 92       	push	r0
 1ba:	0f b6       	in	r0, 0x3f	; 63
 1bc:	0f 92       	push	r0
 1be:	11 24       	eor	r1, r1
 1c0:	0b b6       	in	r0, 0x3b	; 59
 1c2:	0f 92       	push	r0
 1c4:	2f 93       	push	r18
 1c6:	3f 93       	push	r19
 1c8:	4f 93       	push	r20
 1ca:	5f 93       	push	r21
 1cc:	6f 93       	push	r22
 1ce:	7f 93       	push	r23
 1d0:	8f 93       	push	r24
 1d2:	9f 93       	push	r25
 1d4:	af 93       	push	r26
 1d6:	bf 93       	push	r27
 1d8:	ef 93       	push	r30
 1da:	ff 93       	push	r31
	TCCR4B = 0b00000000;
 1dc:	10 92 a1 00 	sts	0x00A1, r1	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	x10Sender.zeroCross();
 1e0:	86 e6       	ldi	r24, 0x66	; 102
 1e2:	92 e0       	ldi	r25, 0x02	; 2
 1e4:	e0 d0       	rcall	.+448    	; 0x3a6 <_ZN6Sender9zeroCrossEv>
}
 1e6:	ff 91       	pop	r31
 1e8:	ef 91       	pop	r30
 1ea:	bf 91       	pop	r27
 1ec:	af 91       	pop	r26
 1ee:	9f 91       	pop	r25
 1f0:	8f 91       	pop	r24
 1f2:	7f 91       	pop	r23
 1f4:	6f 91       	pop	r22
 1f6:	5f 91       	pop	r21
 1f8:	4f 91       	pop	r20
 1fa:	3f 91       	pop	r19
 1fc:	2f 91       	pop	r18
 1fe:	0f 90       	pop	r0
 200:	0b be       	out	0x3b, r0	; 59
 202:	0f 90       	pop	r0
 204:	0f be       	out	0x3f, r0	; 63
 206:	0f 90       	pop	r0
 208:	1f 90       	pop	r1
 20a:	18 95       	reti

0000020c <__vector_1>:

ISR(INT0_vect)
{
 20c:	1f 92       	push	r1
 20e:	0f 92       	push	r0
 210:	0f b6       	in	r0, 0x3f	; 63
 212:	0f 92       	push	r0
 214:	11 24       	eor	r1, r1
 216:	0b b6       	in	r0, 0x3b	; 59
 218:	0f 92       	push	r0
 21a:	2f 93       	push	r18
 21c:	3f 93       	push	r19
 21e:	4f 93       	push	r20
 220:	5f 93       	push	r21
 222:	6f 93       	push	r22
 224:	7f 93       	push	r23
 226:	8f 93       	push	r24
 228:	9f 93       	push	r25
 22a:	af 93       	push	r26
 22c:	bf 93       	push	r27
 22e:	ef 93       	push	r30
 230:	ff 93       	push	r31
	x10Sender.zeroCross();
 232:	86 e6       	ldi	r24, 0x66	; 102
 234:	92 e0       	ldi	r25, 0x02	; 2
 236:	b7 d0       	rcall	.+366    	; 0x3a6 <_ZN6Sender9zeroCrossEv>
	TCCR3B = 0b00000001;
 238:	81 e0       	ldi	r24, 0x01	; 1
 23a:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
	TCNT3  = 0xFFFF - 44447;
 23e:	80 e6       	ldi	r24, 0x60	; 96
 240:	92 e5       	ldi	r25, 0x52	; 82
 242:	90 93 95 00 	sts	0x0095, r25	; 0x800095 <__TEXT_REGION_LENGTH__+0x700095>
 246:	80 93 94 00 	sts	0x0094, r24	; 0x800094 <__TEXT_REGION_LENGTH__+0x700094>
	
	TCCR4B = 0b00000011;
 24a:	83 e0       	ldi	r24, 0x03	; 3
 24c:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	TCNT4  = 0xFFFF - 1388;
 250:	83 e9       	ldi	r24, 0x93	; 147
 252:	9a ef       	ldi	r25, 0xFA	; 250
 254:	90 93 a5 00 	sts	0x00A5, r25	; 0x8000a5 <__TEXT_REGION_LENGTH__+0x7000a5>
 258:	80 93 a4 00 	sts	0x00A4, r24	; 0x8000a4 <__TEXT_REGION_LENGTH__+0x7000a4>
}
 25c:	ff 91       	pop	r31
 25e:	ef 91       	pop	r30
 260:	bf 91       	pop	r27
 262:	af 91       	pop	r26
 264:	9f 91       	pop	r25
 266:	8f 91       	pop	r24
 268:	7f 91       	pop	r23
 26a:	6f 91       	pop	r22
 26c:	5f 91       	pop	r21
 26e:	4f 91       	pop	r20
 270:	3f 91       	pop	r19
 272:	2f 91       	pop	r18
 274:	0f 90       	pop	r0
 276:	0b be       	out	0x3b, r0	; 59
 278:	0f 90       	pop	r0
 27a:	0f be       	out	0x3f, r0	; 63
 27c:	0f 90       	pop	r0
 27e:	1f 90       	pop	r1
 280:	18 95       	reti

00000282 <main>:


int main(void)
{
	sei();
 282:	78 94       	sei
	
	// Setup timer0 to transmit 120 kHz signal.
	TCCR0A = 0b01000010;
 284:	82 e4       	ldi	r24, 0x42	; 66
 286:	84 bd       	out	0x24, r24	; 36
	TCCR0B = 0b00000000;
 288:	15 bc       	out	0x25, r1	; 37
	OCR0A  = 66;
 28a:	87 bd       	out	0x27, r24	; 39
	
	// Setup timer1 for 1 ms delay.
	TCCR1A = 0b00000000;
 28c:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x700080>
	TCCR1B = 0b00000000;
 290:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
	TIMSK1 = 0b00000001;
 294:	81 e0       	ldi	r24, 0x01	; 1
 296:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x70006f>
	
	// Setup timer3 for 2.778 ms delay.
	TCCR3A = 0b00000000;
 29a:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x700090>
	TCCR3B = 0b00000000;
 29e:	10 92 91 00 	sts	0x0091, r1	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
	TIMSK3 = 0b00000001;
 2a2:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__TEXT_REGION_LENGTH__+0x700071>
	
	// Setup timer4 for 5.556 ms delay.
	TCCR4A = 0b00000000;
 2a6:	10 92 a0 00 	sts	0x00A0, r1	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	TCCR4B = 0b00000000;
 2aa:	10 92 a1 00 	sts	0x00A1, r1	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	TIMSK4 = 0b00000001;
 2ae:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
	
	// Setup int0 for Zero-Cross Detection
	EICRA = 0b00000001;
 2b2:	80 93 69 00 	sts	0x0069, r24	; 0x800069 <__TEXT_REGION_LENGTH__+0x700069>
	EIMSK = 0b00000001;
 2b6:	8d bb       	out	0x1d, r24	; 29
	
	DDRA = 0x00;
 2b8:	11 b8       	out	0x01, r1	; 1
	DDRD = 0x00;
 2ba:	1a b8       	out	0x0a, r1	; 10
	
	// 1110 01101001 01101001 01 1110 01101001 01101001 01 000000
    
    while (1) 
    {
		if ((PINA & 1) == 0)
 2bc:	00 99       	sbic	0x00, 0	; 0
 2be:	05 c0       	rjmp	.+10     	; 0x2ca <main+0x48>
			x10Sender.sendCommand(ON, 0b0110);
 2c0:	46 e0       	ldi	r20, 0x06	; 6
 2c2:	62 e0       	ldi	r22, 0x02	; 2
 2c4:	86 e6       	ldi	r24, 0x66	; 102
 2c6:	92 e0       	ldi	r25, 0x02	; 2
 2c8:	91 d0       	rcall	.+290    	; 0x3ec <_ZN6Sender11sendCommandE8commandsc>
			
		if ((PINA & 2) == 0)
 2ca:	01 99       	sbic	0x00, 1	; 0
 2cc:	f7 cf       	rjmp	.-18     	; 0x2bc <main+0x3a>
			x10Sender.sendCommand(OFF, 0b0110);
 2ce:	46 e0       	ldi	r20, 0x06	; 6
 2d0:	63 e0       	ldi	r22, 0x03	; 3
 2d2:	86 e6       	ldi	r24, 0x66	; 102
 2d4:	92 e0       	ldi	r25, 0x02	; 2
 2d6:	8a d0       	rcall	.+276    	; 0x3ec <_ZN6Sender11sendCommandE8commandsc>
 2d8:	f1 cf       	rjmp	.-30     	; 0x2bc <main+0x3a>

000002da <_GLOBAL__sub_I_x10Sender>:
#include <avr/io.h>
#include <avr/interrupt.h>

#include "Sender.h"

Sender x10Sender(0b0110);
 2da:	66 e0       	ldi	r22, 0x06	; 6
 2dc:	86 e6       	ldi	r24, 0x66	; 102
 2de:	92 e0       	ldi	r25, 0x02	; 2
 2e0:	01 c0       	rjmp	.+2      	; 0x2e4 <_ZN6SenderC1Ec>
 2e2:	08 95       	ret

000002e4 <_ZN6SenderC1Ec>:
 *  Author: oskar
 */ 

#include "Sender.h"

 Sender::Sender(char houseCode)
 2e4:	cf 93       	push	r28
 2e6:	df 93       	push	r29
 2e8:	cd b7       	in	r28, 0x3d	; 61
 2ea:	de b7       	in	r29, 0x3e	; 62
 2ec:	c5 56       	subi	r28, 0x65	; 101
 2ee:	d1 09       	sbc	r29, r1
 2f0:	0f b6       	in	r0, 0x3f	; 63
 2f2:	f8 94       	cli
 2f4:	de bf       	out	0x3e, r29	; 62
 2f6:	0f be       	out	0x3f, r0	; 63
 2f8:	cd bf       	out	0x3d, r28	; 61
 2fa:	ac 01       	movw	r20, r24
{
	m_houseCode = houseCode;
 2fc:	fc 01       	movw	r30, r24
 2fe:	60 83       	st	Z, r22
	m_currentState = IDLE;
 300:	11 82       	std	Z+1, r1	; 0x01
	
	// Setup buffer with standard template.
	char temp[101] = "1110000000000000000001111000000000000000000100000011100000000000000000101110000000000000000010000000";
 302:	85 e6       	ldi	r24, 0x65	; 101
 304:	e0 e0       	ldi	r30, 0x00	; 0
 306:	f2 e0       	ldi	r31, 0x02	; 2
 308:	de 01       	movw	r26, r28
 30a:	11 96       	adiw	r26, 0x01	; 1
 30c:	01 90       	ld	r0, Z+
 30e:	0d 92       	st	X+, r0
 310:	8a 95       	dec	r24
 312:	e1 f7       	brne	.-8      	; 0x30c <_ZN6SenderC1Ec+0x28>
 314:	fe 01       	movw	r30, r28
 316:	31 96       	adiw	r30, 0x01	; 1
 318:	da 01       	movw	r26, r20
 31a:	12 96       	adiw	r26, 0x02	; 2
 31c:	9e 01       	movw	r18, r28
 31e:	2a 59       	subi	r18, 0x9A	; 154
 320:	3f 4f       	sbci	r19, 0xFF	; 255
	
	for (int i = 0; i < 101; i++)
	{
		m_buffer[i] = temp[i];
 322:	91 91       	ld	r25, Z+
 324:	9d 93       	st	X+, r25
	m_currentState = IDLE;
	
	// Setup buffer with standard template.
	char temp[101] = "1110000000000000000001111000000000000000000100000011100000000000000000101110000000000000000010000000";
	
	for (int i = 0; i < 101; i++)
 326:	2e 17       	cp	r18, r30
 328:	3f 07       	cpc	r19, r31
 32a:	d9 f7       	brne	.-10     	; 0x322 <_ZN6SenderC1Ec+0x3e>
	
	// Loop through house code and add house code to buffer.
	for (int i = 0; i < 4; i++)
	{
		// If bit position 'i' of the house code is 1.
		if (((m_houseCode >> (3 - i)) & 1) == 1)
 32c:	fa 01       	movw	r30, r20
 32e:	60 81       	ld	r22, Z
 330:	70 e0       	ldi	r23, 0x00	; 0
 332:	da 01       	movw	r26, r20
 334:	5c 96       	adiw	r26, 0x1c	; 28
 336:	23 e0       	ldi	r18, 0x03	; 3
 338:	30 e0       	ldi	r19, 0x00	; 0
			m_buffer[77 + i * 2] = '0';
		}
		// If bit position 'i' of the house code is 0.
		else
		{
			m_buffer[4  + i * 2] = '0';
 33a:	90 e3       	ldi	r25, 0x30	; 48
			m_buffer[5  + i * 2] = '1';
 33c:	81 e3       	ldi	r24, 0x31	; 49
	
	// Loop through house code and add house code to buffer.
	for (int i = 0; i < 4; i++)
	{
		// If bit position 'i' of the house code is 1.
		if (((m_houseCode >> (3 - i)) & 1) == 1)
 33e:	ab 01       	movw	r20, r22
 340:	02 2e       	mov	r0, r18
 342:	02 c0       	rjmp	.+4      	; 0x348 <_ZN6SenderC1Ec+0x64>
 344:	55 95       	asr	r21
 346:	47 95       	ror	r20
 348:	0a 94       	dec	r0
 34a:	e2 f7       	brpl	.-8      	; 0x344 <_ZN6SenderC1Ec+0x60>
 34c:	40 ff       	sbrs	r20, 0
 34e:	0d c0       	rjmp	.+26     	; 0x36a <_ZN6SenderC1Ec+0x86>
		{
			m_buffer[4  + i * 2] = '1';
 350:	86 83       	std	Z+6, r24	; 0x06
			m_buffer[5  + i * 2] = '0';
 352:	97 83       	std	Z+7, r25	; 0x07
			
			m_buffer[26 + i * 2] = '1';
 354:	8c 93       	st	X, r24
			m_buffer[27 + i * 2] = '0';
 356:	95 8f       	std	Z+29, r25	; 0x1d
			
			m_buffer[54 + i * 2] = '1';
 358:	80 af       	std	Z+56, r24	; 0x38
			m_buffer[55 + i * 2] = '0';
 35a:	91 af       	std	Z+57, r25	; 0x39
			
			m_buffer[76 + i * 2] = '1';
 35c:	d2 96       	adiw	r26, 0x32	; 50
 35e:	8c 93       	st	X, r24
 360:	d2 97       	sbiw	r26, 0x32	; 50
			m_buffer[77 + i * 2] = '0';
 362:	d3 96       	adiw	r26, 0x33	; 51
 364:	9c 93       	st	X, r25
 366:	d3 97       	sbiw	r26, 0x33	; 51
 368:	0c c0       	rjmp	.+24     	; 0x382 <_ZN6SenderC1Ec+0x9e>
		}
		// If bit position 'i' of the house code is 0.
		else
		{
			m_buffer[4  + i * 2] = '0';
 36a:	96 83       	std	Z+6, r25	; 0x06
			m_buffer[5  + i * 2] = '1';
 36c:	87 83       	std	Z+7, r24	; 0x07
			
			m_buffer[26 + i * 2] = '0';
 36e:	9c 93       	st	X, r25
			m_buffer[27 + i * 2] = '1';
 370:	85 8f       	std	Z+29, r24	; 0x1d
			
			m_buffer[54 + i * 2] = '0';
 372:	90 af       	std	Z+56, r25	; 0x38
			m_buffer[55 + i * 2] = '1';
 374:	81 af       	std	Z+57, r24	; 0x39
			
			m_buffer[76 + i * 2] = '0';
 376:	d2 96       	adiw	r26, 0x32	; 50
 378:	9c 93       	st	X, r25
 37a:	d2 97       	sbiw	r26, 0x32	; 50
			m_buffer[77 + i * 2] = '1';
 37c:	d3 96       	adiw	r26, 0x33	; 51
 37e:	8c 93       	st	X, r24
 380:	d3 97       	sbiw	r26, 0x33	; 51
 382:	21 50       	subi	r18, 0x01	; 1
 384:	31 09       	sbc	r19, r1
 386:	32 96       	adiw	r30, 0x02	; 2
 388:	12 96       	adiw	r26, 0x02	; 2
	{
		m_buffer[i] = temp[i];
	}
	
	// Loop through house code and add house code to buffer.
	for (int i = 0; i < 4; i++)
 38a:	2f 3f       	cpi	r18, 0xFF	; 255
 38c:	4f ef       	ldi	r20, 0xFF	; 255
 38e:	34 07       	cpc	r19, r20
 390:	b1 f6       	brne	.-84     	; 0x33e <_ZN6SenderC1Ec+0x5a>
			
			m_buffer[76 + i * 2] = '0';
			m_buffer[77 + i * 2] = '1';
		}
	}
}
 392:	cb 59       	subi	r28, 0x9B	; 155
 394:	df 4f       	sbci	r29, 0xFF	; 255
 396:	0f b6       	in	r0, 0x3f	; 63
 398:	f8 94       	cli
 39a:	de bf       	out	0x3e, r29	; 62
 39c:	0f be       	out	0x3f, r0	; 63
 39e:	cd bf       	out	0x3d, r28	; 61
 3a0:	df 91       	pop	r29
 3a2:	cf 91       	pop	r28
 3a4:	08 95       	ret

000003a6 <_ZN6Sender9zeroCrossEv>:

void Sender::zeroCross()
{
	// If Unit doesn't have command to send, exit function.
	if (m_currentState == IDLE) return;
 3a6:	fc 01       	movw	r30, r24
 3a8:	21 81       	ldd	r18, Z+1	; 0x01
 3aa:	22 23       	and	r18, r18
 3ac:	f1 f0       	breq	.+60     	; 0x3ea <_ZN6Sender9zeroCrossEv+0x44>
	
	// If next bit to send is '1', activate 120kHz signal.
	if (m_buffer[m_dynIndex] == '1')
 3ae:	e9 59       	subi	r30, 0x99	; 153
 3b0:	ff 4f       	sbci	r31, 0xFF	; 255
 3b2:	20 81       	ld	r18, Z
 3b4:	fc 01       	movw	r30, r24
 3b6:	e2 0f       	add	r30, r18
 3b8:	f1 1d       	adc	r31, r1
 3ba:	22 81       	ldd	r18, Z+2	; 0x02
 3bc:	21 33       	cpi	r18, 0x31	; 49
 3be:	59 f4       	brne	.+22     	; 0x3d6 <_ZN6Sender9zeroCrossEv+0x30>
	{
		TCCR0B = 0b00000001;
 3c0:	21 e0       	ldi	r18, 0x01	; 1
 3c2:	25 bd       	out	0x25, r18	; 37
		TCCR1B = 0b00000001;
 3c4:	20 93 81 00 	sts	0x0081, r18	; 0x800081 <__TEXT_REGION_LENGTH__+0x700081>
		TCNT1  = 0xffff - 16000;
 3c8:	2f e7       	ldi	r18, 0x7F	; 127
 3ca:	31 ec       	ldi	r19, 0xC1	; 193
 3cc:	30 93 85 00 	sts	0x0085, r19	; 0x800085 <__TEXT_REGION_LENGTH__+0x700085>
 3d0:	20 93 84 00 	sts	0x0084, r18	; 0x800084 <__TEXT_REGION_LENGTH__+0x700084>
		DDRB  |= 0b10000000;
 3d4:	27 9a       	sbi	0x04, 7	; 4
	}
	
	// Increment dynamic index.
	m_dynIndex++;
 3d6:	fc 01       	movw	r30, r24
 3d8:	e9 59       	subi	r30, 0x99	; 153
 3da:	ff 4f       	sbci	r31, 0xFF	; 255
 3dc:	20 81       	ld	r18, Z
 3de:	2f 5f       	subi	r18, 0xFF	; 255
 3e0:	20 83       	st	Z, r18
	
	// If we've reached the end of buffer, set state to IDLE.
	if (m_dynIndex >= 101)
 3e2:	25 36       	cpi	r18, 0x65	; 101
 3e4:	10 f0       	brcs	.+4      	; 0x3ea <_ZN6Sender9zeroCrossEv+0x44>
	{
		m_currentState = IDLE;
 3e6:	fc 01       	movw	r30, r24
 3e8:	11 82       	std	Z+1, r1	; 0x01
 3ea:	08 95       	ret

000003ec <_ZN6Sender11sendCommandE8commandsc>:
	}
}

void Sender::sendCommand(commands command, char unit)
{
 3ec:	ef 92       	push	r14
 3ee:	ff 92       	push	r15
 3f0:	0f 93       	push	r16
 3f2:	1f 93       	push	r17
 3f4:	cf 93       	push	r28
 3f6:	df 93       	push	r29
 3f8:	ec 01       	movw	r28, r24
	// If Unit is currently sending command, exit function.
	if (m_currentState == SENDING) return;
 3fa:	89 81       	ldd	r24, Y+1	; 0x01
 3fc:	81 30       	cpi	r24, 0x01	; 1
 3fe:	09 f4       	brne	.+2      	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
 400:	48 c0       	rjmp	.+144    	; 0x492 <__LOCK_REGION_LENGTH__+0x92>
 402:	de 01       	movw	r26, r28
 404:	1e 96       	adiw	r26, 0x0e	; 14
 406:	fe 01       	movw	r30, r28
 408:	b4 96       	adiw	r30, 0x24	; 36
 40a:	23 e0       	ldi	r18, 0x03	; 3
 40c:	30 e0       	ldi	r19, 0x00	; 0
	
	// Loop through unit and command. Add both to buffer.
	for (int i = 0; i < 4; i++)
	{
		// If bit position 'i' of unit is 1.
		if (((unit >> (3 - i)) & 1) == 1)
 40e:	e4 2e       	mov	r14, r20
 410:	f1 2c       	mov	r15, r1
			m_buffer[35 + i * 2] = '0';
		}
		// If bit position 'i' of unit is 0.
		else
		{
			m_buffer[12 + i * 2] = '0';
 412:	50 e3       	ldi	r21, 0x30	; 48
			m_buffer[13 + i * 2] = '1';
 414:	91 e3       	ldi	r25, 0x31	; 49
			m_buffer[34 + i * 2] = '0';
			m_buffer[35 + i * 2] = '1';
		}
		
		// If bit position 'i' of command is 1.
		if (((command >> (3 - i)) & 1) == 1)
 416:	70 e0       	ldi	r23, 0x00	; 0
	
	// Loop through unit and command. Add both to buffer.
	for (int i = 0; i < 4; i++)
	{
		// If bit position 'i' of unit is 1.
		if (((unit >> (3 - i)) & 1) == 1)
 418:	82 2f       	mov	r24, r18
 41a:	87 01       	movw	r16, r14
 41c:	02 2e       	mov	r0, r18
 41e:	02 c0       	rjmp	.+4      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
 420:	15 95       	asr	r17
 422:	07 95       	ror	r16
 424:	0a 94       	dec	r0
 426:	e2 f7       	brpl	.-8      	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
 428:	00 ff       	sbrs	r16, 0
 42a:	09 c0       	rjmp	.+18     	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
		{
			m_buffer[12 + i * 2] = '1';
 42c:	9c 93       	st	X, r25
			m_buffer[13 + i * 2] = '0';
 42e:	11 96       	adiw	r26, 0x01	; 1
 430:	5c 93       	st	X, r21
 432:	11 97       	sbiw	r26, 0x01	; 1
			
			m_buffer[34 + i * 2] = '1';
 434:	90 83       	st	Z, r25
			m_buffer[35 + i * 2] = '0';
 436:	57 96       	adiw	r26, 0x17	; 23
 438:	5c 93       	st	X, r21
 43a:	57 97       	sbiw	r26, 0x17	; 23
 43c:	08 c0       	rjmp	.+16     	; 0x44e <__LOCK_REGION_LENGTH__+0x4e>
		}
		// If bit position 'i' of unit is 0.
		else
		{
			m_buffer[12 + i * 2] = '0';
 43e:	5c 93       	st	X, r21
			m_buffer[13 + i * 2] = '1';
 440:	11 96       	adiw	r26, 0x01	; 1
 442:	9c 93       	st	X, r25
 444:	11 97       	sbiw	r26, 0x01	; 1
			
			m_buffer[34 + i * 2] = '0';
 446:	50 83       	st	Z, r21
			m_buffer[35 + i * 2] = '1';
 448:	57 96       	adiw	r26, 0x17	; 23
 44a:	9c 93       	st	X, r25
 44c:	57 97       	sbiw	r26, 0x17	; 23
		}
		
		// If bit position 'i' of command is 1.
		if (((command >> (3 - i)) & 1) == 1)
 44e:	8b 01       	movw	r16, r22
 450:	02 c0       	rjmp	.+4      	; 0x456 <__LOCK_REGION_LENGTH__+0x56>
 452:	15 95       	asr	r17
 454:	07 95       	ror	r16
 456:	8a 95       	dec	r24
 458:	e2 f7       	brpl	.-8      	; 0x452 <__LOCK_REGION_LENGTH__+0x52>
 45a:	00 ff       	sbrs	r16, 0
 45c:	07 c0       	rjmp	.+14     	; 0x46c <__LOCK_REGION_LENGTH__+0x6c>
		{
			m_buffer[62 + i * 2] = '1';
 45e:	94 8f       	std	Z+28, r25	; 0x1c
			m_buffer[63 + i * 2] = '0';
 460:	d3 96       	adiw	r26, 0x33	; 51
 462:	5c 93       	st	X, r21
 464:	d3 97       	sbiw	r26, 0x33	; 51
			
			m_buffer[84 + i * 2] = '1';
 466:	92 ab       	std	Z+50, r25	; 0x32
			m_buffer[85 + i * 2] = '0';
 468:	53 ab       	std	Z+51, r21	; 0x33
 46a:	06 c0       	rjmp	.+12     	; 0x478 <__LOCK_REGION_LENGTH__+0x78>
		}
		// If bit position 'i' of command is 0.
		else
		{
			m_buffer[62 + i * 2] = '0';
 46c:	54 8f       	std	Z+28, r21	; 0x1c
			m_buffer[63 + i * 2] = '1';
 46e:	d3 96       	adiw	r26, 0x33	; 51
 470:	9c 93       	st	X, r25
 472:	d3 97       	sbiw	r26, 0x33	; 51
			
			m_buffer[84 + i * 2] = '0';
 474:	52 ab       	std	Z+50, r21	; 0x32
			m_buffer[85 + i * 2] = '1';
 476:	93 ab       	std	Z+51, r25	; 0x33
 478:	21 50       	subi	r18, 0x01	; 1
 47a:	31 09       	sbc	r19, r1
 47c:	12 96       	adiw	r26, 0x02	; 2
 47e:	32 96       	adiw	r30, 0x02	; 2
{
	// If Unit is currently sending command, exit function.
	if (m_currentState == SENDING) return;
	
	// Loop through unit and command. Add both to buffer.
	for (int i = 0; i < 4; i++)
 480:	2f 3f       	cpi	r18, 0xFF	; 255
 482:	8f ef       	ldi	r24, 0xFF	; 255
 484:	38 07       	cpc	r19, r24
 486:	41 f6       	brne	.-112    	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
			m_buffer[85 + i * 2] = '1';
		}
	}
	
	// Change state to SENDING.
	m_currentState = SENDING;
 488:	81 e0       	ldi	r24, 0x01	; 1
 48a:	89 83       	std	Y+1, r24	; 0x01
	
	// Reset dynamic index to 0.
	m_dynIndex = 0;
 48c:	c9 59       	subi	r28, 0x99	; 153
 48e:	df 4f       	sbci	r29, 0xFF	; 255
 490:	18 82       	st	Y, r1
}
 492:	df 91       	pop	r29
 494:	cf 91       	pop	r28
 496:	1f 91       	pop	r17
 498:	0f 91       	pop	r16
 49a:	ff 90       	pop	r15
 49c:	ef 90       	pop	r14
 49e:	08 95       	ret

000004a0 <__tablejump2__>:
 4a0:	ee 0f       	add	r30, r30
 4a2:	ff 1f       	adc	r31, r31
 4a4:	88 1f       	adc	r24, r24
 4a6:	8b bf       	out	0x3b, r24	; 59
 4a8:	07 90       	elpm	r0, Z+
 4aa:	f6 91       	elpm	r31, Z
 4ac:	e0 2d       	mov	r30, r0
 4ae:	19 94       	eijmp

000004b0 <_exit>:
 4b0:	f8 94       	cli

000004b2 <__stop_program>:
 4b2:	ff cf       	rjmp	.-2      	; 0x4b2 <__stop_program>
